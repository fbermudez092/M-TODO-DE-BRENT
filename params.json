{
  "name": "M-todo-de-brent",
  "tagline": "",
  "body": "# M-TODO-DE-BRENT\r\n\r\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n%%%%%%%%%%%%%                                                   %%%%%%%%%%%%%%\r\n%%%%%%%%%%%%%                    MÉTODO DE BRENT                %%%%%%%%%%%%%%\r\n%%%%%%%%%%%%%                                                   %%%%%%%%%%%%%%\r\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n\r\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n%%%%%                                                                      %%%%%\r\n%%%%%                       DEFINICIÓN DEL PROBLEMA:                       %%%%%\r\n%%%%%    Mientras que el método de la secante y posición falsa convergen   %%%%%     \r\n%%%%%      formalmente más rápido que el método de la bisección, uno       %%%%%\r\n%%%%%     encuentra funciones patológicas de práctica para los cuales      %%%%%     \r\n%%%%%   bisección converge más rápidamente. Estos pueden ser, funciones    %%%%%\r\n%%%%%   discontinuas agitadas, o incluso funciones suaves si la segunda    %%%%%     \r\n%%%%% derivada cambia abruptamente cerca de la raíz. Bisección siempre a   %%%%%\r\n%%%%%  la mitad el intervalo, mientras que la secante y posición falsa a   %%%%%     \r\n%%%%%    veces pueden pasar muchos ciclos acercándose lentamente a los     %%%%%\r\n%%%%%    límites lejanos más cerca de la raíz. Por otro lado el Método     %%%%%     \r\n%%%%%   Ridders hace un trabajo mucho mejor, pero también a veces puede    %%%%%\r\n%%%%%       ser engañado. ¿Hay una manera de combinar la convergencia      %%%%%     \r\n%%%%%            super-lineal con la seguridad de bisección?               %%%%%\r\n%%%%%                                                                      %%%%%\r\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n\r\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n%%%%%                                                                 %%%%%\r\n%%%%%                         VALORES DE ENTRADA:                     %%%%%\r\n%%%%% func: Es una función a la cual se desea calcular una            %%%%%  \r\n%%%%%      aproximación a su raíz.                                    %%%%%      \r\n%%%%% x1,x2: Son los extremos del intervalo que contiene a la raíz    %%%%%\r\n%%%%%      la función fun c                                           %%%%%   \r\n%%%%% TOL: Es la tolerancia que deseamos tener en la aproximación     %%%%%   \r\n%%%%%      de la raíz                                                 %%%%%   \r\n%%%%%                                                                 %%%%%\r\n%%%%%                         VALORES DE SALIDA:                      %%%%%\r\n%%%%%             la función devuelve un vector [p itmax]             %%%%%     \r\n%%%%% p: Es la aproximación a la raíz                                 %%%%%\r\n%%%%% itmax: Es la cantidad de veces que se evaluo la función         %%%%%   \r\n%%%%%                                                                 %%%%%\r\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n\r\nfunction [p itmax] = Brent(func,x1,x2,TOL)\r\n\r\n\r\nITMAX=10000;        % valor máximo de iteraciones.\r\nEPS=3.0*(10^-8);    % presición para punto flotante\r\na=x1;\r\nb=x2;\r\nfa=feval(func,a);  %Evalua la funcion en el punto dado\r\nfb=feval(func,b);\r\nif((fa>0) & (fb>0)) || ((fa<0) & (fb<0)); %Verifica si la raíz se encuentra en el intervalo dado.\r\n    error('Procedimiento terminado sin exito, SELECIONE OTRO INTERVALO');\r\nelse\r\n    c=b;\r\n    fc=fb;\r\n    iter=0;   % Guardar el número de iteraciones\r\n    while iter<ITMAX;\r\n        if((fb>0) & (fc>0)) || ((fb<0) & (fc<0));\r\n            c=a; \r\n            fc=fa;\r\n            d=(b-a);\r\n            e=d;\r\n        end\r\n        if abs(fc)<abs(fb);\r\n            a=b;\r\n            b=c;\r\n            c=a;\r\n            fa=fb;\r\n            fb=fc;\r\n            fc=fa;\r\n        end\r\n        tol1=2*EPS*abs(b)+ 0.5*TOL; %Verificación de Convergencia.\r\n        xm=0.5*(c-b);\r\n        if(abs(xm)<=tol1) || (fb==0);\r\n            p=b;\r\n            itmax=iter;\r\n            break\r\n        end\r\n        if(abs(e)>=tol1 && abs(fa)>abs(fb))\r\n            s=fb/fa; %Intentar interpolación cuadrática inversa.\r\n            if(a==c);\r\n                p=2*xm*s;\r\n                q=1-s;\r\n            else\r\n                q=fa/fc;\r\n                r=fb/fc;\r\n                p=s*(2*xm*q*(q-r)-(b-a)*(r-1));\r\n                q=(q-1)*(r-1)*(s-1);\r\n            end\r\n            if(p>0); %Comprobar si en los límites.\r\n                q=-q;\r\n                p=abs(p);\r\n            end\r\n            if(2*p < min(3*xm*q-abs(tol1*q),abs(e*q)));\r\n                e=d; %Aceptar la interpolación.\r\n                d=p/q;\r\n            else\r\n                d=xm; %La interpolación ha fallado. Usar el método de bisección.\r\n                e=d;\r\n            end\r\n        else %Límites disminuyendo muy lentamente. Usar el método de bisección.\r\n            d=xm;\r\n            e=d;\r\n        end\r\n        a=b; %Mueva la última mejor estimación de a.\r\n        fa=fb;\r\n        if(abs(d)>tol1); %Evaluar la nueva raíz\r\n            b=b+d;\r\n        else\r\n            if sign(xm)==0;\r\n                b=b+abs(tol1)*(-1);\r\n            else\r\n                b=b+abs(tol1);\r\n            end\r\n        end\r\n        fb=feval(func,b);\r\n        iter=iter+1;\r\n    end\r\n    if iter==ITMAX\r\n    \terror ('La funcion Brent excedio el máximo de iteraciones');\r\n    end\r\n    p=b;\r\n    itmax=iter;\r\nend\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}