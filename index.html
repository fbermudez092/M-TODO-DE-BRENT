<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>M-todo-de-brent by fbermudez092</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">M-todo-de-brent</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/fbermudez092/M-TODO-DE-BRENT" class="btn">View on GitHub</a>
      <a href="https://github.com/fbermudez092/M-TODO-DE-BRENT/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/fbermudez092/M-TODO-DE-BRENT/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="m-todo-de-brent" class="anchor" href="#m-todo-de-brent" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>M-TODO-DE-BRENT</h1>

<p>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%                                                   %%%%%%%%%%%%%%
%%%%%%%%%%%%%                    MÉTODO DE BRENT                %%%%%%%%%%%%%%
%%%%%%%%%%%%%                                                   %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</p>

<p>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%                                                                      %%%%%
%%%%%                       DEFINICIÓN DEL PROBLEMA:                       %%%%%
%%%%%    Mientras que el método de la secante y posición falsa convergen   %%%%%<br>
%%%%%      formalmente más rápido que el método de la bisección, uno       %%%%%
%%%%%     encuentra funciones patológicas de práctica para los cuales      %%%%%<br>
%%%%%   bisección converge más rápidamente. Estos pueden ser, funciones    %%%%%
%%%%%   discontinuas agitadas, o incluso funciones suaves si la segunda    %%%%%<br>
%%%%% derivada cambia abruptamente cerca de la raíz. Bisección siempre a   %%%%%
%%%%%  la mitad el intervalo, mientras que la secante y posición falsa a   %%%%%<br>
%%%%%    veces pueden pasar muchos ciclos acercándose lentamente a los     %%%%%
%%%%%    límites lejanos más cerca de la raíz. Por otro lado el Método     %%%%%<br>
%%%%%   Ridders hace un trabajo mucho mejor, pero también a veces puede    %%%%%
%%%%%       ser engañado. ¿Hay una manera de combinar la convergencia      %%%%%<br>
%%%%%            super-lineal con la seguridad de bisección?               %%%%%
%%%%%                                                                      %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</p>

<p>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%                                                                 %%%%%
%%%%%                         VALORES DE ENTRADA:                     %%%%%
%%%%% func: Es una función a la cual se desea calcular una            %%%%%<br>
%%%%%      aproximación a su raíz.                                    %%%%%<br>
%%%%% x1,x2: Son los extremos del intervalo que contiene a la raíz    %%%%%
%%%%%      la función fun c                                           %%%%%<br>
%%%%% TOL: Es la tolerancia que deseamos tener en la aproximación     %%%%%<br>
%%%%%      de la raíz                                                 %%%%%<br>
%%%%%                                                                 %%%%%
%%%%%                         VALORES DE SALIDA:                      %%%%%
%%%%%             la función devuelve un vector [p itmax]             %%%%%<br>
%%%%% p: Es la aproximación a la raíz                                 %%%%%
%%%%% itmax: Es la cantidad de veces que se evaluo la función         %%%%%<br>
%%%%%                                                                 %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</p>

<p>function [p itmax] = Brent(func,x1,x2,TOL)</p>

<p>ITMAX=10000;        % valor máximo de iteraciones.
EPS=3.0<em>(10^-8);    % presición para punto flotante
a=x1;
b=x2;
fa=feval(func,a);  %Evalua la funcion en el punto dado
fb=feval(func,b);
if((fa&gt;0) &amp; (fb&gt;0)) || ((fa0) &amp; (fc&gt;0)) || ((fb&lt;0) &amp; (fc&lt;0));
            c=a; 
            fc=fa;
            d=(b-a);
            e=d;
        end
        if abs(fc)&lt;abs(fb);
            a=b;
            b=c;
            c=a;
            fa=fb;
            fb=fc;
            fc=fa;
        end
        tol1=2</em>EPS<em>abs(b)+ 0.5</em>TOL; %Verificación de Convergencia.
        xm=0.5<em>(c-b);
        if(abs(xm)&lt;=tol1) || (fb==0);
            p=b;
            itmax=iter;
            break
        end
        if(abs(e)&gt;=tol1 &amp;&amp; abs(fa)&gt;abs(fb))
            s=fb/fa; %Intentar interpolación cuadrática inversa.
            if(a==c);
                p=2</em>xm<em>s;
                q=1-s;
            else
                q=fa/fc;
                r=fb/fc;
                p=s</em>(2<em>xm</em>q<em>(q-r)-(b-a)</em>(r-1));
                q=(q-1)<em>(r-1)</em>(s-1);
            end
            if(p&gt;0); %Comprobar si en los límites.
                q=-q;
                p=abs(p);
            end
            if(2<em>p &lt; min(3</em>xm<em>q-abs(tol1</em>q),abs(e<em>q)));
                e=d; %Aceptar la interpolación.
                d=p/q;
            else
                d=xm; %La interpolación ha fallado. Usar el método de bisección.
                e=d;
            end
        else %Límites disminuyendo muy lentamente. Usar el método de bisección.
            d=xm;
            e=d;
        end
        a=b; %Mueva la última mejor estimación de a.
        fa=fb;
        if(abs(d)&gt;tol1); %Evaluar la nueva raíz
            b=b+d;
        else
            if sign(xm)==0;
                b=b+abs(tol1)</em>(-1);
            else
                b=b+abs(tol1);
            end
        end
        fb=feval(func,b);
        iter=iter+1;
    end
    if iter==ITMAX
        error ('La funcion Brent excedio el máximo de iteraciones');
    end
    p=b;
    itmax=iter;
end</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/fbermudez092/M-TODO-DE-BRENT">M-todo-de-brent</a> is maintained by <a href="https://github.com/fbermudez092">fbermudez092</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
